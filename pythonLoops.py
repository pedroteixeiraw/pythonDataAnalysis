# We begin every video by importing the standard set of Python modules that we will need throughout this course. This cell does that, so we execute it by selecting it with a cursor and pressing Shift + Return. If you've written computer code before, you must be familiar with loops. They occur in many different computing problems, and they allow us to automate repetitive operations. They're also a good topic to start a quick review of the Python code language. We see loops in a concrete example. Consider a combinatorial problem of breaking $1 U.S. into all possible combinations of coins. For instance, four quarters, two quarters and five 10 cent dimes, and so on. Now, if we have to add coins up to $1, we can use at most $1 coin, two 50 cent coins, four quarters, and so on. We can also mix different values. You can already see how we're going to need several nested loops to figure out all the combinations. We start with a very simple-minded strategy. For each face value, we enumerate all possible quantities, zero to one $1 coins, zero to two half dollar coins, and so on. So we'll need six nested loops. Luckily, Python will keep track of them. The basic structure of a loop in Python is for variable in iterable. We follow that with a block of code that we are repeating with a variable taking on the values provided by the iterable. But what is an iterable? We can think of it as a black box that keeps providing new values until it runs out. A simple example is a Python list. Perhaps the most commonly used iterable is range, which provides integer values from a start value to an end value, exclusive of the end value. This means that range 0 to 10 counts from zero to nine. There are many reasons for this convention. For instance, by looking at the end value, we see immediately the total number of elements, in this case, 10. In the end, we just have to accept this as one of the building assumptions of the language. Range has a couple more interesting features. If we omit the start value, it is assumed to be zero. And also we can provide a step argument to move through the range in increments larger than one. When we do that, we also need to specify the initial value to avoid confusion. Let's go back to our dollar and build out our nested loops. We need from zero to one $1 coins, which means that the first range object will be range two. We write it here as 1 + 1. We then proceed with other coins, one loop for each. Each nested loop is indented with respect to its parent. We do this with a tab. Inside the innermost loop, we will check whether the total amount is $1. If so, we had the combination to a list, which we initialize as the empty list. So let's try this out. Very good. The first few combinations seem to check out fine. It turns out that there are 293 ways to get $1 out of change. This is the solution to the problem that we post. However, in this analysis, it often happens that the solution raises a new question. For instance, how many ways to make $2 out of change, or three? Does the number of combination increase linearly or quadratically? What we need to do is to take the code we wrote and generalize it to answer those questions. Before we do so, we make a couple of changes to our code to make it faster and easier to generalize. This is an example of refactoring. The first change is that we will not loop by count, but by value using the step argument. For instance, instead of the loop over quarters from zero through four, we will loop over the values. The second change is to recognize that we don't actually need the innermost loop. As long as the total up to that point is less or equal $1, then we can always make up the difference with pennies. So we write one fewer loop. This looks all right. We're almost done. Now we can take our code and make it into a function find_combinations by replacing the value 100 everywhere with a variable argument. We also wrap our computation with def and return statements as appropriate for a function. So let's see how we can make 2 and $3. You may be curious to know how fast this number grows. A Matplotlib plot should give us an idea. In fact, this number grows approximately as the fifth power of the total value.

